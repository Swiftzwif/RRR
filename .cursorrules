# Git Workflow Rules for RRR Project

## Branch Strategy

### Branch Naming Convention

- `main` - Production-ready code
- `develop` - Integration branch for features
- `feature/<ticket-number>-<short-description>` - New features
- `fix/<ticket-number>-<short-description>` - Bug fixes
- `hotfix/<ticket-number>-<short-description>` - Urgent production fixes
- `refactor/<scope>-<description>` - Code refactoring
- `chore/<description>` - Maintenance tasks (deps, configs, etc.)
- `docs/<description>` - Documentation updates

### Branch Creation Rules

1. **ALWAYS create a new branch** for each distinct piece of work
2. **NEVER commit directly to main or develop**
3. Create branches from `develop` for features/fixes
4. Create branches from `main` only for hotfixes
5. Keep branches small and focused on a single concern

## Commit Conventions

### Commit Message Format

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Types

- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, missing semicolons, etc.)
- `refactor`: Code refactoring without changing functionality
- `perf`: Performance improvements
- `test`: Adding or updating tests
- `chore`: Maintenance tasks
- `build`: Build system or dependency updates
- `ci`: CI/CD configuration changes

### Scopes (for this project)

- `assessment`: Assessment-related features
- `course`: Course module
- `payment`: Payment integrations
- `auth`: Authentication
- `email`: Email functionality
- `ui`: UI components
- `api`: API routes
- `db`: Database changes
- `config`: Configuration changes

### Commit Rules

1. **Atomic commits** - Each commit should represent one logical change
2. **Commit early and often** - Don't wait until end of day
3. **Write meaningful commit messages** - Future you will thank present you
4. **No commits with failing tests or linting errors**

### Examples

```
feat(assessment): add progress indicator to assessment stepper
fix(payment): resolve Square API webhook validation error
docs(api): update API documentation with new endpoints
refactor(ui): extract common button styles to shared component
```

## Workflow Commands

### Starting New Work

```bash
# 1. Ensure you're on develop and it's up to date
git checkout develop
git pull origin develop

# 2. Create a new feature branch
git checkout -b feature/TRJ-123-user-authentication

# 3. Work on your feature with atomic commits
git add -p  # Stage changes interactively
git commit -m "feat(auth): implement JWT token generation"
```

### Daily Workflow

```bash
# Start of day - update your branch
git checkout develop
git pull origin develop
git checkout feature/your-branch
git merge develop  # or rebase if preferred

# During work - commit frequently
git add -p
git commit -m "feat(scope): description"

# End of work session - push your branch
git push origin feature/your-branch
```

### Completing Work

```bash
# 1. Ensure all tests pass
npm run test
npm run lint

# 2. Update from develop one final time
git checkout develop
git pull origin develop
git checkout feature/your-branch
git merge develop

# 3. Push and create PR
git push origin feature/your-branch
# Create PR on GitHub targeting develop branch
```

## Code Review Process

### Before Creating a PR

1. Self-review your code using `git diff develop`
2. Ensure all tests pass
3. Update documentation if needed
4. Remove any console.logs or debug code
5. Squash WIP commits if needed (but keep logical separation)

### PR Title Format

```
[TYPE] Scope: Description

Examples:
[FEAT] Assessment: Add email capture after assessment completion
[FIX] Payment: Resolve Square webhook timeout issue
[REFACTOR] UI: Consolidate button component variants
```

### PR Description Template

```markdown
## Summary
Brief description of what this PR does

## Changes
- Bullet list of specific changes
- Include any breaking changes

## Testing
- [ ] Unit tests pass
- [ ] Manual testing completed
- [ ] No console errors

## Screenshots
(if applicable)

## Related Issues
Closes #123
```

## Git History Organization

### Finding Changes Quickly

```bash
# Find commits by author
git log --author="YourName" --oneline

# Find commits by message
git log --grep="payment" --oneline

# Find commits affecting specific file
git log --follow -- path/to/file

# Find commits in date range
git log --since="2024-01-01" --until="2024-01-31"

# See branch history visually
git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
```

### Useful Aliases (add to ~/.gitconfig)

```
[alias]
    # Show concise status
    st = status -sb
    
    # Show pretty log
    lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
    
    # Show files changed in each commit
    ll = log --pretty=format:'%C(yellow)%h%Cred%d %Creset%s%Cblue [%cn]' --decorate --numstat
    
    # Interactive rebase
    rb = rebase -i
    
    # Amend last commit
    amend = commit --amend --no-edit
    
    # Undo last commit (keep changes)
    undo = reset HEAD~1 --mixed
```

## Implementation Rules for AI Assistant

When working in this codebase, I will:

1. **Create a new branch** for each distinct task:

   ```bash
   git checkout -b feature/description-of-work
   ```

2. **Make atomic commits** with proper messages:

   ```bash
   git add -p  # Review changes before staging
   git commit -m "type(scope): clear description"
   ```

3. **Push regularly** to avoid losing work:

   ```bash
   git push origin current-branch
   ```

4. **Never commit directly to main or develop**

5. **Always run tests before committing**:

   ```bash
   npm run lint
   npm run test
   npm run build
   ```

6. **Keep PRs small and focused** - If a task is too large, break it into multiple PRs

7. **Update branch from develop before creating PR**

## Emergency Procedures

### If you accidentally commit to main/develop

```bash
# Create a new branch with your changes
git checkout -b feature/emergency-fix

# Reset main/develop to origin
git checkout main
git reset --hard origin/main
```

### If you need to undo commits

```bash
# Undo last commit but keep changes
git reset --soft HEAD~1

# Undo commits and discard changes
git reset --hard HEAD~1
```

### If merge conflicts occur

```bash
# Update your branch
git checkout develop
git pull origin develop
git checkout your-branch
git merge develop

# Resolve conflicts in editor
# Then:
git add .
git commit -m "merge: resolve conflicts with develop"
```

## Project-Specific Rules

### For trajectory2 app

- All payment-related changes require extra review
- Database schema changes need migration files
- UI changes need screenshot in PR
- Email template changes need preview screenshot

### Branch Lifecycle

1. Create branch from develop
2. Work on feature with regular commits
3. Keep branch updated with develop (daily)
4. Create PR when ready
5. Address review comments
6. Merge to develop after approval
7. Delete branch after merge

## Monitoring Branch Health

Run these periodically:

```bash
# Show all branches
git branch -a

# Show merged branches (safe to delete)
git branch --merged develop

# Clean up deleted remote branches
git remote prune origin

# Delete local branches that are merged
git branch --merged develop | grep -v develop | xargs -n 1 git branch -d
```

---

## Pull Request Management (Veteran's Guide)

### Creating PRs Like a Pro

#### Pre-PR Checklist (Non-Negotiable)

```bash
# 1. Self-review every line of code
git diff develop --name-status  # See what you changed
git diff develop                # Review every change

# 2. Ensure branch is up-to-date
git fetch origin
git merge origin/develop        # Or rebase if you prefer

# 3. Run full test suite
npm run lint
npm run typecheck
npm run test
npm run build

# 4. Check for accidental inclusions
git status                      # Verify staged files
git log develop..HEAD --oneline # Verify commits going into PR
```

#### Writing PR Descriptions That Matter

A good PR description answers these questions:

1. **What** changed? (Summary)
2. **Why** did it change? (Context/motivation)
3. **How** does it work? (Technical approach)
4. **How** was it tested? (Validation)
5. **What** are the risks? (Deployment concerns)

**Example PR Description:**

```markdown
## Summary
Add Supabase authentication system with email/password and OAuth support

## Context
Users need to create accounts to access paid content and track their progress.
This implements the authentication layer required before we can launch the course.

## Technical Approach
- Integrated `@supabase/ssr` for Next.js 15 server components
- Created middleware for route protection
- Implemented session management with cookie-based auth
- Added login, signup, and account management pages

## Testing
- [x] Manual testing of all auth flows
- [x] Verified session persistence across page reloads
- [x] Tested protected routes redirect to login
- [x] Verified email confirmation flow
- [x] Tested OAuth providers (Google, GitHub)

## Deployment Notes
- Requires `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` env vars
- Run migrations: `supabase db push`
- Enable email auth in Supabase dashboard

## Breaking Changes
None

## Screenshots
[Attach login/signup page screenshots]

## Related Issues
Closes #45, Closes #67
```

### PR Title Best Practices

Format: `[TYPE] Scope: Imperative mood description (max 72 chars)`

**Good Examples:**

- `[FEAT] Auth: Implement Supabase authentication system`
- `[FIX] Payment: Prevent duplicate Square webhook processing`
- `[REFACTOR] UI: Extract shared button components to design system`

**Bad Examples:**

- ‚ùå `Updated stuff` (Too vague)
- ‚ùå `[FEAT] Added authentication` (Wrong mood, no scope)
- ‚ùå `Fix` (No context whatsoever)

### Code Review as a Reviewer

#### Your Responsibilities

1. **Understand the context** - Read the full PR description
2. **Run the code locally** - Don't just read, test it
3. **Be constructive** - Suggest solutions, not just problems
4. **Be timely** - Review within 24 hours
5. **Approve only if you'd deploy it** - Your approval means you trust it

#### Review Checklist

```markdown
**Architecture & Design**
- [ ] Does this fit the overall system design?
- [ ] Are there simpler approaches?
- [ ] Is it over-engineered or under-engineered?

**Code Quality**
- [ ] Is the code readable and self-documenting?
- [ ] Are naming conventions followed?
- [ ] Is error handling comprehensive?
- [ ] Are edge cases handled?

**Testing**
- [ ] Are there sufficient tests?
- [ ] Do tests actually test the right things?
- [ ] Are tests maintainable?

**Security**
- [ ] Are inputs validated?
- [ ] Is user data properly sanitized?
- [ ] Are secrets/keys hardcoded? (Never!)
- [ ] Is authentication/authorization correct?

**Performance**
- [ ] Are there obvious performance issues?
- [ ] Are database queries optimized?
- [ ] Are large operations paginated?

**Documentation**
- [ ] Are complex algorithms explained?
- [ ] Is public API documented?
- [ ] Are breaking changes highlighted?
```

#### Comment Guidelines

**Good Comments:**

```markdown
üéØ **Suggestion:** Consider extracting this logic into a custom hook for reusability
```

```
üìö **Question:** Why did we choose POST over GET here? GET seems more RESTful for this read operation.
```

```
‚ö†Ô∏è **Concern:** This query could be slow with large datasets. Consider adding pagination.
```

```
üí° **Nitpick:** Variable name `data` is too generic. `assessmentResults` would be clearer.
```

**Bad Comments:**

- ‚ùå "This is wrong" (No explanation)
- ‚ùå "Just use X instead" (No reasoning)
- ‚ùå "I don't like this" (Personal preference without technical merit)

### Code Review as an Author

#### Responding to Reviews

1. **Never take it personally** - It's about the code, not you
2. **Thank reviewers** - They're helping you improve
3. **Explain your reasoning** - But be open to changing your mind
4. **Update the PR** - Address feedback quickly
5. **Ask for re-review** - After making changes

#### When to Push Back

- Reviewer suggests approach that conflicts with project architecture
- Suggestion is out of scope for this PR
- Comment is purely stylistic preference without technical merit

**How to push back professionally:**

```markdown
Thanks for the suggestion! I considered this approach but went with the current 
implementation because:
1. It maintains consistency with our existing auth patterns
2. The alternative would require refactoring 5 other files
3. Performance testing showed no difference between approaches

Happy to discuss further if you have concerns!
```

---

## Merge Strategies (When & Why)

### 1. Merge Commit (Default - Recommended)

```bash
git checkout develop
git merge --no-ff feature/new-feature
```

**When to use:**

- Most pull requests (default)
- Want complete history preservation
- Multiple commits tell a story

**Pros:**

- Preserves complete branch history
- Easy to revert entire feature
- Shows who worked on what and when

**Cons:**

- Can create "merge bubbles" in history
- Graph gets complex with many branches

### 2. Squash and Merge

```bash
git checkout develop
git merge --squash feature/new-feature
git commit -m "feat(scope): consolidated feature description"
```

**When to use:**

- Branch has many WIP/fixup commits
- Want clean linear history
- Feature is logically one change
- Experimental work with messy history

**Pros:**

- Clean linear history
- One commit per feature
- Easy to cherry-pick later

**Cons:**

- Loses development history
- Can't revert individual commits
- Blame shows squash commit, not original author

### 3. Rebase and Merge

```bash
git checkout feature/new-feature
git rebase develop
git checkout develop
git merge feature/new-feature  # Will be fast-forward
```

**When to use:**

- Want linear history without merge commits
- Commits are already clean and atomic
- Small, focused changes

**Pros:**

- Cleanest linear history
- Each commit stands alone
- No merge commits

**Cons:**

- Rewrites history (never do this on shared branches)
- Loses context of when feature was integrated
- Can be confusing for beginners

### 4. Fast-Forward Only

```bash
git merge --ff-only feature/new-feature
```

**When to use:**

- Branch is already rebased on develop
- Want to enforce linear history
- Branch is only 1-2 commits ahead

**Decision Tree:**

```
Has many WIP commits? 
    Yes ‚Üí Squash and Merge
    No ‚Üì
    
Is it a hotfix or small fix (1-3 commits)?
    Yes ‚Üí Rebase and Merge
    No ‚Üì
    
Is it a feature with good commit history?
    Yes ‚Üí Merge Commit (--no-ff)
    No ‚Üí Clean up commits first, then decide
```

---

## Conflict Resolution (Expert Level)

### Understanding Conflicts

Conflicts happen when:

1. Same line changed in both branches
2. File moved/renamed in one branch, modified in another
3. File deleted in one branch, modified in another

### Strategy #1: Merge Conflicts (Recommended for most cases)

```bash
# Update your branch
git checkout feature/your-branch
git fetch origin
git merge origin/develop

# Conflicts appear - resolve them
# Look for markers: <<<<<<<, =======, >>>>>>>

# After resolving each file:
git add path/to/resolved-file.tsx

# Complete the merge
git commit -m "merge: resolve conflicts with develop

Resolved conflicts:
- file1.tsx: kept incoming changes (better implementation)
- file2.tsx: combined both approaches
- file3.tsx: kept current changes (feature-specific logic)"
```

### Strategy #2: Rebase Conflicts (For clean history)

```bash
git fetch origin
git rebase origin/develop

# Conflicts appear, resolve them
git add resolved-file.tsx
git rebase --continue

# Repeat until rebase completes
# Force push (careful!)
git push --force-with-lease origin your-branch
```

### Conflict Resolution Tools

**Command Line:**

```bash
# See conflicted files
git status

# See what changed
git diff

# Take their version
git checkout --theirs path/to/file.tsx

# Take our version
git checkout --ours path/to/file.tsx

# Use merge tool
git mergetool
```

### Complex Conflict Patterns

**Pattern 1: Package.json conflicts**

```bash
# Always take both dependencies, resolve manually
git checkout --ours package.json
git checkout --theirs --patch package.json  # Pick their new deps
# Then manually verify package.json is valid
npm install  # Regenerate package-lock.json
git add package.json package-lock.json
```

**Pattern 2: Database migration conflicts**

```bash
# Never auto-resolve migration conflicts
# Check both migrations, create new one that combines them
# Rename migrations with new timestamp if needed
```

**Pattern 3: Large refactor conflicts**

```bash
# If conflicts are extensive (>10 files):
# 1. Consider rebasing from scratch
git rebase --abort
git rebase -i origin/develop  # Interactive rebase
# 2. Or, accept incoming and manually reapply changes
git checkout --theirs .
git checkout --ours -- path/to/feature/files/
```

---

## Post-Merge Workflow (Critical!)

### Immediately After Merging

```bash
# 1. Verify the merge on develop
git checkout develop
git pull origin develop

# 2. Run full test suite
npm run lint
npm run typecheck
npm run test
npm run build

# 3. If tests pass, push to remote
git push origin develop

# 4. Delete merged branch
git branch -d feature/your-branch
git push origin --delete feature/your-branch

# 5. Verify on GitHub that PR is closed and branch is deleted
```

### If Something Breaks After Merge

#### Option 1: Quick Fix (Small issue)

```bash
git checkout develop
git checkout -b hotfix/post-merge-fix
# Make fix
git commit -m "fix: resolve issue from merge"
git push origin hotfix/post-merge-fix
# Fast PR and merge
```

#### Option 2: Revert (Bigger issue)

```bash
# Revert the entire merge
git revert -m 1 <merge-commit-hash>
git push origin develop

# Fix issues in original branch
git checkout feature/your-branch
# Make fixes
git push origin feature/your-branch
# Create new PR
```

---

## Advanced PR Patterns

### Stacked PRs (Dependent Features)

When Feature B depends on Feature A:

```bash
# Create Feature A
git checkout develop
git checkout -b feature/A-foundation
# Work and push
git push origin feature/A-foundation
# Create PR #1: feature/A-foundation ‚Üí develop

# Create Feature B based on Feature A
git checkout feature/A-foundation
git checkout -b feature/B-builds-on-A
# Work and push
git push origin feature/B-builds-on-A
# Create PR #2: feature/B-builds-on-A ‚Üí feature/A-foundation

# After A merges to develop:
git checkout feature/B-builds-on-A
git rebase develop
# Update PR #2 target to develop
```

### Draft PRs (Work in Progress)

```bash
# Create PR early as draft
git push origin feature/WIP-exploration
# On GitHub: Create Pull Request ‚Üí Convert to Draft

# Benefits:
# - Early feedback
# - CI runs continuously  
# - Team visibility
# - Can request review on specific commits

# When ready:
# On GitHub: Ready for review
```

### Hotfix PRs (Production Emergencies)

```bash
# Branch from main (not develop!)
git checkout main
git pull origin main
git checkout -b hotfix/critical-payment-bug

# Make minimal fix
git commit -m "fix(payment): prevent double charging on retry"
git push origin hotfix/critical-payment-bug

# Create PR targeting main
# Get immediate review
# After merge to main:
git checkout develop
git merge main  # Bring hotfix to develop too
git push origin develop
```

---

## Merge Automation Best Practices

### Auto-Merge Criteria (Use with Caution)

Safe to auto-merge if:

- All CI checks pass
- Required approvals met (minimum 1-2)
- No merge conflicts
- Author has sufficient experience
- Changes are low-risk (docs, tests, minor UI)

**Never** auto-merge:

- Database migrations
- Authentication/authorization changes
- Payment processing logic
- Security-related code
- Major refactors
- Breaking changes

### Using GitHub CLI for Merges

```bash
# Install GitHub CLI
brew install gh

# Authenticate
gh auth login

# List PRs
gh pr list

# Check PR status
gh pr view 123

# Merge PR
gh pr merge 123 --squash --delete-branch

# Merge with custom message
gh pr merge 123 --merge --body "Merging after successful QA"
```

---

## Team Collaboration Patterns

### Multiple Developers on Same Branch

```bash
# Before pushing, always pull with rebase
git pull --rebase origin feature/shared-branch

# If conflicts, resolve and continue
git rebase --continue

# Then push
git push origin feature/shared-branch
```

### Long-Running Feature Branches

```bash
# Keep updated with develop (do this daily!)
git checkout feature/long-running
git fetch origin
git merge origin/develop  # Or rebase if history is clean

# Resolve conflicts immediately, don't let them accumulate
# Push frequently
git push origin feature/long-running
```

### Release Branches

```bash
# Create release branch from develop
git checkout develop
git checkout -b release/v1.2.0

# Only bug fixes go into release branch
# Cherry-pick from develop if needed
git cherry-pick <commit-hash>

# When ready, merge to main
git checkout main
git merge --no-ff release/v1.2.0
git tag -a v1.2.0 -m "Release version 1.2.0"
git push origin main --tags

# Also merge back to develop
git checkout develop
git merge release/v1.2.0
git push origin develop

# Delete release branch
git branch -d release/v1.2.0
git push origin --delete release/v1.2.0
```

---

## Git Hygiene for Seniors

### Regular Maintenance Tasks

**Weekly:**

```bash
# Clean up merged branches
git fetch --prune
git branch --merged develop | grep -v develop | grep -v main | xargs -n 1 git branch -d

# Update all tracking branches
git fetch --all --prune
```

**Monthly:**

```bash
# Clean up unreachable objects
git gc --aggressive --prune=now

# Verify repository integrity
git fsck
```

### Git Performance Optimization

```bash
# If repo gets slow:
git maintenance start  # Enable background maintenance

# For large repos:
git config feature.manyFiles true
git config index.threads true
```

---

## Troubleshooting Common Merge Issues

### "I merged the wrong branch!"

```bash
# Undo the merge (if not pushed yet)
git reset --hard HEAD~1

# If already pushed
git revert -m 1 HEAD
git push origin develop
```

### "My PR has 100 commits and is a mess"

```bash
# Squash everything into one commit
git checkout feature/messy-branch
git reset --soft develop
git commit -m "feat(scope): clean consolidated commit message"
git push --force-with-lease origin feature/messy-branch
```

### "I need to update PR but it has conflicts"

```bash
# Backup your work first
git checkout feature/your-branch
git branch backup/your-branch-$(date +%Y%m%d)

# Now safely rebase
git fetch origin
git rebase origin/develop

# If rebase goes wrong
git rebase --abort
git reset --hard backup/your-branch-YYYYMMDD
```

### "Merge created duplicate commits"

```bash
# You probably merged and rebased - don't do both!
# Fix: use rerere (reuse recorded resolution)
git config --global rerere.enabled true

# This remembers conflict resolutions
```

---

## The Golden Rules (Never Forget)

1. **Never force push to main or develop** - Ever.
2. **Never merge your own PR without approval** - Unless it's a doc fix.
3. **Never commit secrets** - Use environment variables.
4. **Never merge with failing tests** - Fix them first.
5. **Never leave debug code in PRs** - Clean up console.logs.
6. **Never create PRs with >500 lines changed** - Split it up.
7. **Never merge without updating documentation** - Future you will thank you.
8. **Never use `--force`** - Use `--force-with-lease` instead.
9. **Never delete remote branches manually** - Let GitHub auto-delete after merge.
10. **Never commit commented-out code** - Delete it, git remembers everything.

---

Remember: Good git hygiene makes everyone's life easier, including future you!

## Wisdom from the Trenches

> "A pull request is not just code‚Äîit's a story. Make it a story worth reading."

> "The best merge is the one that doesn't break production at 3 AM."

> "If you're scared to merge, you didn't test enough."

> "Conflicts are inevitable. How you handle them defines you as an engineer."

> "Small PRs get reviewed faster, merged sooner, and cause fewer problems."

---

# Browser Automation & UI Testing Protocol (Veteran's Standard)

## The Non-Negotiable UI Testing Mandate

> "If you didn't see it in a real browser, you don't know if it works."

### Core Principle

**EVERY UI change, style modification, or user interaction update MUST be validated in an actual browser using automation tools BEFORE and AFTER making changes.**

This is not optional. This is not a suggestion. This is how professionals ship UI code.

---

## When Browser Automation is MANDATORY

### Always Required For:

- ‚úÖ **UI Component Changes** - Any React/Next.js component modification
- ‚úÖ **CSS/Styling Updates** - Tailwind classes, global styles, theme changes
- ‚úÖ **Form Implementation** - Inputs, validation, submission flows
- ‚úÖ **Navigation/Routing** - Links, redirects, route protection
- ‚úÖ **Interactive Elements** - Buttons, modals, dropdowns, tabs, accordions
- ‚úÖ **Layout Changes** - Grid, flexbox, positioning, responsive design
- ‚úÖ **Animation/Transitions** - Any visual motion or state changes
- ‚úÖ **Data Display** - Tables, cards, lists, charts
- ‚úÖ **Authentication Flows** - Login, signup, logout, protected routes
- ‚úÖ **Payment Flows** - Checkout, payment forms, confirmation pages
- ‚úÖ **Assessment/Course Pages** - All trajectory2 main features
- ‚úÖ **Error States** - 404, 500, error boundaries, validation errors
- ‚úÖ **Loading States** - Skeletons, spinners, suspense boundaries

### When to Use Browser Tools:

1. **Before touching code** - Understand current state
2. **During development** - Iterate and verify
3. **After changes** - Validate everything works
4. **Before committing** - Final verification
5. **Before creating PR** - Evidence gathering
6. **After pulling changes** - Ensure no regressions

---

## The Veteran's UI Development Workflow

### Phase 1: Pre-Development Reconnaissance (MANDATORY)

```bash
# Step 1: Identify what you're about to change
# Check recent history of the file
git log --oneline -15 -- src/components/YourComponent.tsx
git log --oneline -15 -- src/app/your-page/page.tsx

# Step 2: See what changed in last few commits
git diff HEAD~5 -- src/components/YourComponent.tsx

# Step 3: Check for related changes in the same scope
git log --oneline --since="7 days ago" --grep="ui\|component\|style"

# Step 4: Ensure dev server is running
# Check if it's already running on expected port (3003 for trajectory2)
lsof -i :3003 || npm run dev
```

#### Browser Reconnaissance Checklist:

**BEFORE touching any code, execute this exact sequence:**

1. **Navigate to the page you're about to modify**
   ```
   Use: browser_navigate to http://localhost:3003/your-route
   ```

2. **Take accessibility snapshot**
   ```
   Use: browser_snapshot
   Document current structure and element references
   ```

3. **Check console for existing errors**
   ```
   Use: browser_console_messages
   Document any existing errors (not your fault, but note them)
   ```

4. **Take screenshot of current state**
   ```
   Use: browser_take_screenshot
   Save as: before-change-{component-name}-{timestamp}.png
   ```

5. **Test current functionality**
   - Click all interactive elements
   - Fill out forms if present
   - Test navigation flows
   - Document any existing bugs

6. **Check responsive behavior**
   ```
   Use: browser_resize for desktop (1920x1080), tablet (768x1024), mobile (375x667)
   Take screenshot at each size
   ```

7. **Inspect network requests**
   ```
   Use: browser_network_requests
   Note any failing API calls or slow requests
   ```

**ONLY AFTER completing reconnaissance can you start coding.**

---

### Phase 2: Development with Continuous Validation

**Rule**: Test in browser every 10-15 minutes during active development.

#### Hot Reload Verification:

After each significant change:

```bash
# Let Next.js hot reload (wait 2-3 seconds)
# Then in browser automation:

1. Take new snapshot - browser_snapshot
2. Check console - browser_console_messages  
3. Test the specific feature you just changed
4. Verify no regressions in related features
```

#### Common Issues to Check:

**Styling Issues:**
- Layout breaks at different viewport sizes
- Overlapping elements
- Cut-off text or images
- Incorrect spacing (check against design system)
- Wrong colors (verify against theme)
- Hover states not working
- Focus states missing (accessibility issue)

**Functional Issues:**
- Click handlers not firing
- Form submissions failing silently
- Navigation not working
- Data not displaying
- Loading states stuck
- Error boundaries not catching errors

**Console Errors to Hunt:**
- React hydration mismatches
- Missing key props in lists
- Unhandled promise rejections
- 404s for assets/API calls
- Type errors in browser console
- Warning about deprecated APIs

---

### Phase 3: Post-Development Validation (MANDATORY)

**Before committing, you MUST complete this entire checklist:**

#### Comprehensive Testing Checklist:

```markdown
**Visual Verification**
- [ ] Navigate to page: browser_navigate
- [ ] Take final screenshot: browser_take_screenshot (fullPage: true)
- [ ] Compare before/after screenshots side-by-side
- [ ] Verify design matches design system (spacing, colors, typography)
- [ ] Check all text is readable (contrast, size, line-height)
- [ ] Verify images load correctly (no broken images)
- [ ] Check icons render properly

**Functional Verification**
- [ ] Take snapshot: browser_snapshot
- [ ] Test all interactive elements (buttons, links, forms)
- [ ] Test form validation if applicable
- [ ] Test navigation flows (can user get to this page and back?)
- [ ] Test data loading (if page fetches data)
- [ ] Test error states (force errors if possible)
- [ ] Test loading states (throttle network if needed)

**Console Verification**
- [ ] Check console: browser_console_messages
- [ ] Zero errors (fix all errors)
- [ ] Zero warnings related to your changes
- [ ] Document any pre-existing warnings (not your fault, but note them)

**Responsive Verification**
- [ ] Desktop: browser_resize(1920, 1080) + screenshot
- [ ] Laptop: browser_resize(1366, 768) + screenshot  
- [ ] Tablet: browser_resize(768, 1024) + screenshot
- [ ] Mobile: browser_resize(375, 667) + screenshot
- [ ] All layouts look correct at each size
- [ ] No horizontal scrolling on mobile
- [ ] Touch targets are large enough on mobile (44x44px minimum)

**Accessibility Verification**
- [ ] Take snapshot and verify semantic HTML structure
- [ ] Buttons have accessible labels
- [ ] Images have alt text
- [ ] Forms have proper labels
- [ ] Interactive elements are keyboard accessible (test tab navigation)
- [ ] Focus indicators are visible

**Network Verification**
- [ ] Check network: browser_network_requests
- [ ] All API calls succeed (200/201/204 status codes)
- [ ] No failed requests (unless expected error handling)
- [ ] No excessively slow requests (>3s warning threshold)
- [ ] No unnecessary duplicate requests

**Edge Case Testing**
- [ ] Test with no data (empty states)
- [ ] Test with maximum data (long text, many items)
- [ ] Test with special characters in inputs
- [ ] Test with invalid inputs (if forms)
- [ ] Test with slow network (if data loading)
- [ ] Test rapid clicking (debounce/throttle working?)

**User Flow Testing** (Critical Paths)
- [ ] Can user complete the primary task on this page?
- [ ] Can user navigate to this page from home?
- [ ] Can user navigate away from this page?
- [ ] Does authentication work correctly? (if protected route)
- [ ] Does page state persist correctly? (if applicable)
```

**If ANY item fails, fix it before committing.**

---

## Browser Automation Tool Reference

### Essential Commands

#### Navigation
```typescript
// Navigate to a page
browser_navigate({ url: "http://localhost:3003/assessment" })

// Go back
browser_navigate_back()

// Manage tabs
browser_tabs({ action: "list" })
browser_tabs({ action: "new" })
browser_tabs({ action: "select", index: 0 })
browser_tabs({ action: "close" })
```

#### Inspection
```typescript
// Take accessibility snapshot (USE THIS OFTEN)
browser_snapshot()
// Returns: Page structure with element refs for interaction

// Take screenshot
browser_take_screenshot({ 
  fullPage: true,
  filename: "page-state-{timestamp}.png"
})

// Screenshot specific element (after getting ref from snapshot)
browser_take_screenshot({
  element: "Login button",
  ref: "ref-from-snapshot",
  filename: "login-button.png"
})

// Check console messages
browser_console_messages()
// Returns: All console.log, console.error, console.warn messages

// Check network requests
browser_network_requests()
// Returns: All HTTP requests with status codes, timing, payloads
```

#### Interaction
```typescript
// Click element (get ref from snapshot first)
browser_click({
  element: "Submit button",
  ref: "element-ref-from-snapshot"
})

// Type into input
browser_type({
  element: "Email input",
  ref: "input-ref-from-snapshot",
  text: "test@example.com",
  submit: false  // Set true to press Enter after
})

// Fill entire form at once
browser_fill_form({
  fields: [
    { name: "Email", type: "textbox", ref: "email-ref", value: "test@example.com" },
    { name: "Password", type: "textbox", ref: "pass-ref", value: "SecurePass123!" },
    { name: "Remember me", type: "checkbox", ref: "remember-ref", value: "true" }
  ]
})

// Select dropdown option
browser_select_option({
  element: "Country selector",
  ref: "select-ref",
  values: ["United States"]
})

// Hover over element
browser_hover({
  element: "Tooltip trigger",
  ref: "hover-ref"
})

// Drag and drop
browser_drag({
  startElement: "Draggable item",
  startRef: "drag-ref",
  endElement: "Drop zone",
  endRef: "drop-ref"
})

// Press keyboard key
browser_press_key({ key: "Enter" })
browser_press_key({ key: "Escape" })
browser_press_key({ key: "Tab" })
```

#### Validation
```typescript
// Wait for text to appear
browser_wait_for({ text: "Success!" })

// Wait for text to disappear
browser_wait_for({ textGone: "Loading..." })

// Wait for specific time
browser_wait_for({ time: 2 })  // 2 seconds

// Resize viewport
browser_resize({ width: 375, height: 667 })

// Handle dialogs (alerts, confirms, prompts)
browser_handle_dialog({ 
  accept: true,
  promptText: "Optional text for prompt dialogs"
})

// Execute JavaScript
browser_evaluate({
  function: "() => { return document.title; }"
})

// Execute JavaScript on specific element
browser_evaluate({
  element: "Button",
  ref: "button-ref",
  function: "(element) => { return element.disabled; }"
})
```

---

## Standard Testing Patterns for trajectory2

### Pattern 1: Testing Assessment Flow

```typescript
// 1. Navigate to assessment landing
browser_navigate({ url: "http://localhost:3003/assessment/landing" })

// 2. Snapshot current state
browser_snapshot()

// 3. Click start assessment
browser_click({ element: "Start Assessment Button", ref: "start-button-ref" })

// 4. Wait for page load
browser_wait_for({ text: "Question 1" })

// 5. Snapshot question page
browser_snapshot()

// 6. Take screenshot
browser_take_screenshot({ fullPage: true, filename: "assessment-question-1.png" })

// 7. Answer question
browser_click({ element: "Option A", ref: "option-a-ref" })

// 8. Click next
browser_click({ element: "Next Button", ref: "next-ref" })

// 9. Verify progress updated
browser_snapshot()

// 10. Check console for errors
browser_console_messages()
```

### Pattern 2: Testing Form Submission

```typescript
// 1. Navigate to login
browser_navigate({ url: "http://localhost:3003/login" })

// 2. Snapshot
browser_snapshot()

// 3. Fill form
browser_fill_form({
  fields: [
    { name: "Email", type: "textbox", ref: "email-ref", value: "test@example.com" },
    { name: "Password", type: "textbox", ref: "password-ref", value: "TestPass123!" }
  ]
})

// 4. Submit
browser_click({ element: "Login button", ref: "submit-ref" })

// 5. Wait for navigation
browser_wait_for({ textGone: "Sign in" })

// 6. Verify redirect
// browser_snapshot should show new page

// 7. Check network
browser_network_requests()
// Verify login API call succeeded
```

### Pattern 3: Testing Responsive Layout

```typescript
// Test at all breakpoints
const breakpoints = [
  { name: "mobile", width: 375, height: 667 },
  { name: "tablet", width: 768, height: 1024 },
  { name: "laptop", width: 1366, height: 768 },
  { name: "desktop", width: 1920, height: 1080 }
];

// For each breakpoint:
// 1. Resize
browser_resize({ width: 375, height: 667 })

// 2. Snapshot (check layout structure)
browser_snapshot()

// 3. Screenshot
browser_take_screenshot({ 
  fullPage: true,
  filename: "page-mobile.png"
})

// 4. Test interactions still work
browser_click({ element: "Menu button", ref: "menu-ref" })

// 5. Verify no layout breaks
browser_console_messages()
```

### Pattern 4: Testing Protected Routes

```typescript
// 1. Navigate to protected page without auth
browser_navigate({ url: "http://localhost:3003/course" })

// 2. Wait for redirect
browser_wait_for({ text: "Sign in" })

// 3. Verify redirect to login
browser_snapshot()
// Should show login page, not course page

// 4. Login
browser_fill_form({
  fields: [
    { name: "Email", type: "textbox", ref: "email-ref", value: "user@example.com" },
    { name: "Password", type: "textbox", ref: "pass-ref", value: "ValidPass123!" }
  ]
})
browser_click({ element: "Login", ref: "submit-ref" })

// 5. Navigate to protected page again
browser_navigate({ url: "http://localhost:3003/course" })

// 6. Verify access granted
browser_wait_for({ text: "Course Content" })
browser_snapshot()
```

### Pattern 5: Testing Error States

```typescript
// 1. Navigate to page
browser_navigate({ url: "http://localhost:3003/login" })

// 2. Submit invalid data
browser_fill_form({
  fields: [
    { name: "Email", type: "textbox", ref: "email-ref", value: "invalid-email" },
    { name: "Password", type: "textbox", ref: "pass-ref", value: "123" }
  ]
})
browser_click({ element: "Submit", ref: "submit-ref" })

// 3. Wait for error message
browser_wait_for({ text: "Invalid email" })

// 4. Take screenshot of error state
browser_take_screenshot({ filename: "login-error-state.png" })

// 5. Verify error styling applied
browser_snapshot()
// Should show error messages, red borders, etc.

// 6. Fix errors and resubmit
browser_fill_form({
  fields: [
    { name: "Email", type: "textbox", ref: "email-ref", value: "valid@example.com" },
    { name: "Password", type: "textbox", ref: "pass-ref", value: "ValidPass123!" }
  ]
})
browser_click({ element: "Submit", ref: "submit-ref" })

// 7. Verify errors cleared
browser_wait_for({ textGone: "Invalid email" })
```

---

## PR Requirements for UI Changes

### Screenshots Required in PR Description

For **EVERY** UI change PR, you must include:

1. **Before Screenshots**
   - Desktop view (1920x1080)
   - Mobile view (375x667)
   - Any intermediate breakpoints where layout changes

2. **After Screenshots**  
   - Same views as "before"
   - Show the change is intentional and looks correct

3. **Interaction Screenshots** (if applicable)
   - Hover states
   - Focus states
   - Error states
   - Loading states
   - Success states

4. **Console Screenshot**
   - Show console with zero errors
   - Document any warnings (explain why they're acceptable)

### Video Recording (Optional but Recommended)

For complex interactions:
- Record screen showing the user flow
- Demonstrate the feature works end-to-end
- Show responsive behavior by resizing window

### Browser Testing Evidence

Include in PR description:

```markdown
## Browser Testing Completed

- [x] Tested in browser automation (localhost:3003)
- [x] All console errors resolved (see screenshot)
- [x] Responsive layout verified (mobile, tablet, desktop)
- [x] Accessibility snapshot reviewed (semantic HTML correct)
- [x] User flow tested end-to-end (see video/screenshots)
- [x] Network requests verified (all successful)
- [x] Edge cases tested (empty state, error state, loading state)

### Testing Evidence

**Before:**
![Before Desktop](./screenshots/before-desktop.png)
![Before Mobile](./screenshots/before-mobile.png)

**After:**
![After Desktop](./screenshots/after-desktop.png)
![After Mobile](./screenshots/after-mobile.png)

**Console (Zero Errors):**
![Console Clean](./screenshots/console-clean.png)

**Network Requests:**
![Network Success](./screenshots/network-success.png)
```

---

## Integration with Git Workflow

### Pre-Commit Checklist (UI Changes)

```bash
# 1. Run linter
npm run lint

# 2. Run type check
npm run typecheck

# 3. Run tests (if you have them)
npm run test

# 4. BROWSER VALIDATION (THE IMPORTANT PART)
# - Navigate to affected pages
# - Take snapshots
# - Check console (zero errors)
# - Take screenshots
# - Test responsive layouts
# - Verify user flows work

# 5. Review git diff
git diff

# 6. Stage changes
git add -p

# 7. Commit with evidence
git commit -m "feat(ui): improve assessment stepper layout

- Fixed responsive layout on mobile
- Improved spacing per design system
- Verified in browser automation (zero console errors)
- Tested on mobile (375px), tablet (768px), desktop (1920px)
- Screenshots attached in PR"
```

### Branch Testing Before PR

Before creating PR with UI changes:

```bash
# 1. Merge latest develop
git checkout develop
git pull origin develop
git checkout your-branch
git merge develop

# 2. Rebuild if needed
npm run build

# 3. Restart dev server
npm run dev

# 4. FULL BROWSER REGRESSION TEST
# Test ALL pages affected by your changes:
# - Navigate to each page
# - Take snapshot
# - Check console
# - Screenshot desktop + mobile
# - Test user flows
# - Verify no regressions

# 5. Create PR with all evidence
git push origin your-branch
# Include screenshots and testing checklist in PR description
```

---

## Common UI Issues and How to Catch Them

### Issue 1: Hydration Mismatches

**Symptom:** React warning about mismatched text content

**How to catch:**
```typescript
// 1. Navigate to page
browser_navigate({ url: "http://localhost:3003/page" })

// 2. Check console IMMEDIATELY
browser_console_messages()

// Look for: "Warning: Text content did not match..."
```

**How to fix:**
- Check for Date.now() or Math.random() in render
- Check for browser-only APIs (window, localStorage) without guards
- Use `useEffect` for client-only rendering

### Issue 2: Missing Key Props

**Symptom:** React warning about keys in lists

**How to catch:**
```typescript
browser_console_messages()
// Look for: "Warning: Each child in a list should have a unique "key" prop"
```

**How to fix:**
- Add unique `key` prop to all `.map()` items
- Use stable IDs, not array indices

### Issue 3: Inaccessible Forms

**Symptom:** Can't tab through form, screen reader issues

**How to catch:**
```typescript
// 1. Take snapshot
browser_snapshot()

// 2. Verify structure shows:
// - <label> elements with htmlFor
// - <input> elements with id matching label
// - Proper ARIA attributes
```

**How to fix:**
- Add labels to all inputs
- Add aria-label for icon buttons
- Ensure focusable elements are keyboard accessible

### Issue 4: Responsive Layout Breaks

**Symptom:** Content overflows, overlaps, or looks broken on mobile

**How to catch:**
```typescript
// Test at all breakpoints
browser_resize({ width: 375, height: 667 })
browser_take_screenshot({ fullPage: true })

// Look for:
// - Horizontal scrolling
// - Text cut off
// - Overlapping elements
// - Tiny click targets (<44px)
```

**How to fix:**
- Use responsive Tailwind classes (sm:, md:, lg:)
- Test at 375px width (iPhone SE)
- Use `overflow-x-hidden` carefully
- Ensure touch targets are 44x44px minimum

### Issue 5: Failed API Calls

**Symptom:** Data doesn't load, infinite loading state

**How to catch:**
```typescript
// 1. Navigate to page
browser_navigate({ url: "http://localhost:3003/page" })

// 2. Wait for load
browser_wait_for({ time: 3 })

// 3. Check network
browser_network_requests()

// Look for:
// - 404 errors (wrong endpoint)
// - 401/403 errors (auth issues)
// - 500 errors (server errors)
// - CORS errors
```

**How to fix:**
- Check endpoint URL is correct
- Verify authentication headers
- Check server is running
- Verify CORS configuration

### Issue 6: Z-Index Battles

**Symptom:** Modals behind content, tooltips not showing

**How to catch:**
```typescript
// 1. Open modal/tooltip
browser_click({ element: "Open Modal", ref: "modal-trigger-ref" })

// 2. Take screenshot
browser_take_screenshot({ filename: "modal-z-index.png" })

// 3. Visual inspection:
// - Is modal visible?
// - Is backdrop behind content?
// - Is content on top of backdrop?
```

**How to fix:**
- Use Tailwind's z-index scale (z-10, z-20, z-30, z-40, z-50)
- Modal backdrops: z-40
- Modal content: z-50
- Document z-index usage in design system

---

## The Ultimate Pre-Commit UI Checklist

Print this out. Check every box. Every time.

```markdown
## Pre-Commit UI Validation (THE LAW)

### Code Quality
- [ ] Ran `npm run lint` (zero errors)
- [ ] Ran `npm run typecheck` (zero errors)
- [ ] Ran `npm run build` (successful)
- [ ] Removed all console.log statements
- [ ] Removed all debug code
- [ ] Removed all commented-out code

### Browser Automation Testing
- [ ] Dev server running on correct port
- [ ] Navigated to all affected pages
- [ ] Took accessibility snapshots of all pages
- [ ] Verified semantic HTML structure
- [ ] Checked console (ZERO errors, noted any warnings)
- [ ] Took screenshots (before and after)

### Responsive Testing
- [ ] Tested mobile (375x667) - screenshot taken
- [ ] Tested tablet (768x1024) - screenshot taken  
- [ ] Tested desktop (1920x1080) - screenshot taken
- [ ] No horizontal scrolling on any size
- [ ] All text readable at all sizes
- [ ] All click targets >44px on mobile

### Functional Testing
- [ ] Clicked all buttons (they work)
- [ ] Filled all forms (validation works)
- [ ] Tested all navigation (links work)
- [ ] Tested loading states (if applicable)
- [ ] Tested error states (if applicable)
- [ ] Tested empty states (if applicable)

### Accessibility Testing
- [ ] All buttons have labels
- [ ] All images have alt text
- [ ] All forms have labels
- [ ] Color contrast is sufficient
- [ ] Keyboard navigation works
- [ ] Focus indicators visible

### Network Testing
- [ ] Checked network requests
- [ ] All API calls return 2xx status
- [ ] No failed requests (unless intentional)
- [ ] No slow requests (>3s)

### Git Hygiene
- [ ] Reviewed git diff line-by-line
- [ ] Only committing intended changes
- [ ] Commit message is descriptive
- [ ] Changes match commit message

### Evidence Gathered for PR
- [ ] Before screenshots saved
- [ ] After screenshots saved
- [ ] Console screenshot saved (clean)
- [ ] Network screenshot saved (if relevant)
- [ ] Testing checklist ready for PR description
```

**If ANY box is unchecked, DO NOT COMMIT.**

---

## Special Rules for trajectory2 App

### Assessment Pages
- **MUST** test entire flow start-to-finish
- **MUST** verify progress indicator updates
- **MUST** test both mobile and desktop layouts
- **MUST** verify results page displays correctly
- **MUST** check email capture works

### Course Pages  
- **MUST** verify authentication gates work
- **MUST** test navigation between lessons
- **MUST** verify content displays correctly
- **MUST** test video embeds (if applicable)
- **MUST** verify progress tracking

### Payment Pages
- **MUST** test form validation thoroughly
- **MUST** verify Square integration works
- **MUST** test error states (declined card, etc.)
- **MUST** verify confirmation page displays
- **MUST** check webhook handling (use network tab)

### Story/Landing Pages
- **MUST** verify hero section looks professional
- **MUST** test all CTA buttons work
- **MUST** verify responsive design (critical for conversions)
- **MUST** test smooth scrolling (if applicable)
- **MUST** verify images load and look sharp

---

## Automation Script Examples

### Quick Test Script (Copy-Paste Ready)

For rapid iteration, use this pattern:

```typescript
// RAPID TEST PATTERN
// 1. Navigate
browser_navigate({ url: "http://localhost:3003/your-page" })

// 2. Snapshot + Console + Screenshot
browser_snapshot()
browser_console_messages()
browser_take_screenshot({ fullPage: true })

// 3. Test interaction
browser_click({ element: "Your Button", ref: "button-ref-from-snapshot" })

// 4. Verify
browser_snapshot()
browser_console_messages()
```

### Full Page Audit Script

```typescript
// FULL AUDIT PATTERN
const breakpoints = [
  { w: 375, h: 667, name: "mobile" },
  { w: 768, h: 1024, name: "tablet" },
  { w: 1920, h: 1080, name: "desktop" }
];

// For each breakpoint:
// 1. Resize
browser_resize({ width: 375, height: 667 })

// 2. Navigate
browser_navigate({ url: "http://localhost:3003/page" })

// 3. Snapshot
browser_snapshot()

// 4. Console
browser_console_messages()

// 5. Screenshot
browser_take_screenshot({ 
  fullPage: true,
  filename: `page-mobile.png`
})

// 6. Network
browser_network_requests()

// Repeat for each breakpoint
```

---

## The Golden Rules of UI Testing (MEMORIZE THESE)

1. **Never commit UI changes without browser testing** - NEVER.

2. **Never trust "it works on my machine"** - Test at multiple viewport sizes.

3. **Never ignore console warnings** - They become errors in production.

4. **Never skip accessibility checks** - Lawsuits are expensive.

5. **Never assume hot reload worked** - Hard refresh and verify.

6. **Never commit with failing network requests** - Fix or handle the error.

7. **Never push layout breaks on mobile** - Mobile-first or mobile-same.

8. **Never skip screenshot evidence in PRs** - Pictures or it didn't happen.

9. **Never merge without checking recent changes** - Use `git log` before coding.

10. **Never ship what you haven't clicked** - If you didn't test it, it's broken.

---

## AI Assistant Implementation Protocol

### For Every UI Task, I Will:

1. **FIRST** - Check git history of files I'm about to modify
   ```bash
   git log --oneline -10 -- path/to/file
   git diff HEAD~5 -- path/to/file
   ```

2. **SECOND** - Launch browser automation and inspect current state
   - Navigate to page
   - Take snapshot
   - Check console
   - Take screenshot
   - Document current behavior

3. **THIRD** - Make code changes

4. **FOURTH** - Validate changes in browser
   - Navigate to page again (or hard refresh)
   - Take new snapshot
   - Check console for new errors
   - Take new screenshot
   - Test functionality
   - Test responsive layout

5. **FIFTH** - Compare before/after
   - Side-by-side screenshot comparison
   - Console errors (before vs after)
   - Network requests (before vs after)

6. **SIXTH** - Document findings
   - What changed
   - What was tested
   - What screenshots were taken
   - Any issues found and fixed

7. **SEVENTH** - Prepare PR evidence
   - Gather all screenshots
   - Document testing checklist
   - Note any edge cases tested
   - Highlight any known limitations

### For Every Code Review, I Will:

1. Check the PR description for testing evidence
2. Verify screenshots show before/after
3. Check that console is clean in screenshots
4. Verify responsive testing was done
5. Look for obvious accessibility issues
6. Check that network requests are handled
7. Verify error states are tested

---

## Veteran's Wisdom on UI Testing

> "The browser never lies. Your assumptions do."

> "A screenshot is worth a thousand words. A video is worth a thousand screenshots."

> "Console errors in development become user complaints in production."

> "If you didn't test it on mobile, you didn't test it."

> "Accessibility isn't optional. It's professional responsibility."

> "The best UI test is the one that catches bugs before users do."

> "Inspect recent changes first. Context prevents mistakes."

> "Browser automation isn't overhead. It's insurance."

> "If you can't demonstrate it working, it doesn't work."

> "Test like your reputation depends on it. It does."

---

## Remember

Every pixel matters. Every interaction matters. Every console error matters.

Test thoroughly. Document completely. Ship confidently.

That's the veteran's way.
